package ui;

import Interface.ChatInteraction;
import model.DiffieHellman;
import model.Encrypt;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.PublicKey;
import java.util.Scanner;

public class Server implements ChatInteraction {
    private DataInputStream input;
    private DataOutputStream output;
    private ServerSocket serverSocket;
    private Socket socket;
    private static DiffieHellman diffieHellman;
    private static Encrypt encrypt;
    private static String name;
    private PublicKey key;

    public static void main(String[] args) {

        diffieHellman = new DiffieHellman();
        encrypt = new Encrypt();

        Server server = new Server();
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter port: ");
        String port = sc.nextLine();
        System.out.print("Enter your name: ");
        name = sc.nextLine();

        server.createConnection("", Integer.parseInt(port));
        server.writeData();
    }

    /**
     * This function creates a connection to a server using a specified IP address and port number, and
     * performs a series of actions including exchanging keys and receiving data.
     *
     * @param ip   The IP address of the server to connect to.
     * @param port The port parameter is an Integer that specifies the port number to use for the
     *             connection. Ports are used to identify specific processes or services running on a computer and
     *             allow multiple network connections to be established on a single machine. In this case, the port
     *             number is used to establish a connection with a server at
     */
    @Override
    public void createConnection(String ip, Integer port) {
        Thread thread = new Thread(() -> {
            while (true) {
                try {
                    connectServers(ip, port);
                    flow();
                    exchangeKeys();
                    diffieHellman.generateSecretKey();
                    receiveData();
                } finally {
                    endConnection();
                }
            }
        });
        thread.start();
    }

    /**
     * This function creates a server socket and waits for a client to connect to it, establishing an
     * encrypted chat connection.
     *
     * @param ip   There is no use of the "ip" parameter in the given code snippet. It is not used in the
     *             method implementation.
     * @param port The port number on which the server socket will listen for incoming connections.
     */
    @Override
    public void connectServers(String ip, int port) {
        try {
            serverSocket = new ServerSocket(port);
            printText("Waiting for connection\n");
            socket = serverSocket.accept();
            printText("\nConnection established with: " + socket.getInetAddress().getHostAddress() + "\n");
            printText("This is a end-to-end encrypted chat \n\n");
        } catch (IOException e) {
            System.out.println("Error connecting with client: " + e.getMessage() + "\n");
            System.exit(0);
        }
    }

    /**
     * This function generates and exchanges Diffie-Hellman keys.
     */
    public void exchangeKeys() {
        diffieHellman.generateKeys();
        sendKey(diffieHellman.getPublicKey());
        receiveKey();
    }

    /**
     * This function sends a public key over a socket connection using ObjectOutputStream in Java.
     *
     * @param key The parameter "key" is not used in the given code snippet. Instead, the method sends the
     *            Diffie-Hellman public key generated by the "diffieHellman" object over the socket's output stream.
     */
    @Override
    public void sendKey(PublicKey key) {
        try {
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeObject(diffieHellman.getPublicKey());
            outputStream.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This function receives a public key through an input stream and passes it to a Diffie-Hellman
     * object.
     */
    @Override
    public void receiveKey() {
        try {
            ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
            diffieHellman.receivedPublicKey((PublicKey) inputStream.readObject());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * The function sets up input and output streams for a socket connection in Java.
     */
    @Override
    public void flow() {
        try {
            input = new DataInputStream(socket.getInputStream());
            output = new DataOutputStream(socket.getOutputStream());
            output.flush();
        } catch (IOException e) {
            printText("Error creating chat\n");
        }
    }

    /**
     * This function receives encrypted messages from a socket and decrypts them using a secret key
     * obtained through the Diffie-Hellman key exchange algorithm.
     */
    @Override
    public void receiveData() {
        String message = "";
        try {
            do {
                ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
                String encryptedMessage = (String) inputStream.readObject();
                message = encrypt.decrypt(diffieHellman.getSecretKey(), encryptedMessage);
                printText("\n[" + socket.getInetAddress().getHostAddress() + "]: " + message
                        + "\n[" + name + "]:");
            } while (!message.equalsIgnoreCase(TERMINATE_CONNECTION));
            endConnection();
        } catch (Exception e) {
            printText("Error receiving message: " + e.getMessage() + "\n");
        }
    }

    /**
     * This function writes encrypted messages using the Diffie-Hellman key exchange algorithm.
     */
    @Override
    public void writeData() {
        String message = "";
        while (true) {
            printText("[" + name + "]: ");
            message = getMessage();
            if (message.length() > 0) {
                String encryptedMessage = null;
                try {
                    encryptedMessage = encrypt.encrypt(diffieHellman.getSecretKey(), message);
                } catch (Exception e) {
                    printText("Error writing message: " + e.getMessage() + "\n");
                }
                send(encryptedMessage);
            }
        }
    }

    /**
     * This Java function sends a message through a socket using an ObjectOutputStream.
     *
     * @param message The message to be sent over the socket connection.
     */
    @Override
    public void send(String message) {
        try {
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeObject(message);
            outputStream.flush();
        } catch (IOException e) {
            printText("Error sending message: " + e.getMessage() + "\n");
        }
    }

    /**
     * This function closes the input, output, and socket connections and prints a message before exiting
     * the program.
     */
    @Override
    public void endConnection() {
        try {
            input.close();
            output.close();
            socket.close();
            printText("Chat closed....");
            System.exit(0);

        } catch (IOException e) {
            printText("Error closing chat: " + e.getMessage() + "\n");
            System.exit(0);
        }
    }

    /**
     * This Java function prints a given message to the console.
     *
     * @param message A String variable that contains the message to be printed.
     */
    @Override
    public void printText(String message) {
        System.out.print(message);
    }

    /**
     * This function returns a string input from the user through the console.
     *
     * @return A string that is inputted by the user through the console.
     */
    @Override
    public String getMessage() {
        Scanner scanner = new Scanner(System.in);
        return scanner.nextLine();
    }
}
