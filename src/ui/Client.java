package ui;

import Interface.ChatInteraction;
import model.DiffieHellman;
import model.Encrypt;

import java.io.*;
import java.net.Socket;
import java.security.PublicKey;
import java.util.Scanner;

public class Client implements ChatInteraction {
    private DataInputStream input;
    private DataOutputStream output;
    private Socket socket;
    private static DiffieHellman diffieHellman;
    private static Encrypt encrypt;
    private static String name;
    private PublicKey key;

    public static void main(String[] args) {

        diffieHellman = new DiffieHellman();
        encrypt = new Encrypt();

        Client client = new Client();
        Scanner sc = new Scanner(System.in);

        System.out.print("Enter server IP: ");
        String ip = sc.nextLine();
        System.out.print("Enter port: ");
        String port = sc.nextLine();
        System.out.print("Enter your name: ");
        name = sc.nextLine();

        client.createConnection(ip, Integer.parseInt(port));
        client.writeData();
    }

    /**
     * The function creates a new thread that continuously connects to a server, performs key exchange,
     * generates a secret key, and receives data until the connection is ended.
     *
     * @param ip   The IP address of the server to connect to.
     * @param port The port parameter is an Integer that specifies the port number to use for the
     *             connection. Ports are used to identify specific processes or services running on a computer and
     *             allow multiple network connections to be established on a single machine. In this case, the port
     *             number is used to establish a connection with a server at
     */
    @Override
    public void createConnection(String ip, Integer port) {
        Thread thread = new Thread(() -> {
            while (true) {
                try {
                    connectServers(ip, port);
                    flow();
                    exchangeKeys();
                    diffieHellman.generateSecretKey();
                    receiveData();
                } finally {
                    endConnection();
                }
            }
        });
        thread.start();
    }

    /**
     * This function connects to a server using a specified IP address and port number and prints a message
     * indicating successful connection.
     *
     * @param ip   The IP address of the server to connect to.
     * @param port The port parameter is an integer value that represents the port number on which the
     *             server is listening for incoming connections. It is used to establish a connection between the
     *             client and the server.
     */
    @Override
    public void connectServers(String ip, int port) {
        try {
            socket = new Socket(ip, port);
            printText("\nConnecting with " + socket.getInetAddress().getHostName() + "\n");
            printText("This is a end-to-end encrypted chat \n\n");

        } catch (IOException e) {
            System.out.println("Error connecting with server: " + e.getMessage() + "\n");
            System.exit(0);
        }
    }

    /**
     * The function generates and exchanges Diffie-Hellman public keys.
     */
    public void exchangeKeys() {
        diffieHellman.generateKeys();
        sendKey(diffieHellman.getPublicKey());
        receiveKey();
    }

    /**
     * This function sends a public key over a socket connection using ObjectOutputStream in Java.
     *
     * @param key The parameter "key" is not used in the given code snippet. Instead, the method sends the
     *            Diffie-Hellman public key generated by the "diffieHellman" object over the socket's output stream.
     */
    @Override
    public void sendKey(PublicKey key) {
        try {
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeObject(diffieHellman.getPublicKey());
            outputStream.flush();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This function receives a public key through an input stream and passes it to a Diffie-Hellman
     * object.
     */
    @Override
    public void receiveKey() {
        try {
            ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
            diffieHellman.receivedPublicKey((PublicKey) inputStream.readObject());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * The function sets up input and output streams for a socket connection in Java.
     */
    @Override
    public void flow() {
        try {
            input = new DataInputStream(socket.getInputStream());
            output = new DataOutputStream(socket.getOutputStream());
            output.flush();
        } catch (IOException e) {
            printText("Error creating chat\n");
        }
    }

    /**
     * This function receives encrypted messages from a socket and decrypts them using a secret key
     * obtained through the Diffie-Hellman key exchange algorithm.
     */
    @Override
    public void receiveData() {
        String message = "";
        try {
            do {
                ObjectInputStream inputStream = new ObjectInputStream(socket.getInputStream());
                String encryptedMessage = (String) inputStream.readObject();
                message = encrypt.decrypt(diffieHellman.getSecretKey(), encryptedMessage.toString());
                printText("\n[" + socket.getInetAddress().getHostAddress() + "]: " + message
                        + "\n[" + name + "]:");
            } while (!message.equalsIgnoreCase(TERMINATE_CONNECTION));
            endConnection();
        } catch (Exception e) {
            printText("Error receiving message: " + e.getMessage() + "\n");
        }
    }

    /**
     * This function writes encrypted data to a recipient.
     */
    @Override
    public void writeData() {
        String message = "";
        while (true) {
            printText("[" + name + "]: ");
            message = getMessage();
            if (message.length() > 0) {
                String encryptedMessage = null;
                try {
                    encryptedMessage = encrypt.encrypt(diffieHellman.getSecretKey(), message);
                } catch (Exception e) {
                    printText("Error receiving message: " + e.getMessage() + "\n");
                }
                send(encryptedMessage);
            }
        }
    }

    /**
     * This function sends a message through a socket connection using an ObjectOutputStream.
     *
     * @param message The message to be sent over the socket connection. It is of type String.
     */
    @Override
    public void send(String message) {
        try {
            ObjectOutputStream outputStream = new ObjectOutputStream(socket.getOutputStream());
            outputStream.writeObject(message);
            outputStream.flush();
        } catch (IOException e) {
            printText("Error sending message: " + e.getMessage() + "\n");
        }
    }

    /**
     * This function closes the chat connection by closing the input and output streams and the socket,
     * and prints a message before exiting the program.
     */
    @Override
    public void endConnection() {
        try {
            input.close();
            output.close();
            socket.close();
            printText("Chat closed....");
            System.exit(0);

        } catch (IOException e) {
            printText("Error closing chat: " + e.getMessage() + "\n");
            System.exit(0);
        }
    }

    /**
     * This Java function prints a given message to the console.
     *
     * @param message A String variable that represents the message to be printed.
     */
    @Override
    public void printText(String message) {
        System.out.print(message);
    }

    /**
     * This function returns a string input from the user through the console.
     *
     * @return A String value entered by the user through the console.
     */
    @Override
    public String getMessage() {
        Scanner scanner = new Scanner(System.in);
        return scanner.nextLine();
    }
}
